import { JSONSchema7 } from 'json-schema';
import { AnySchema, LiteralSchema, NullSchema, NumberSchema, BigintSchema, StringSchema, BooleanSchema, NullableSchema, ObjectSchema, RecordSchema, ArraySchema, TupleSchema, IntersectSchema, UnionSchema, VariantSchema, PicklistSchema, EnumSchema, LazySchema, DateSchema, NullishSchema, OptionalSchema, UndefinedSchema, BaseSchema, BaseSchemaAsync } from 'valibot';

/** Get types of the values of a record. */
type ValueOf<T extends Record<any, any>> = T[keyof T];

type SupportedSchemas = AnySchema | LiteralSchema<any> | NullSchema | NumberSchema | BigintSchema | StringSchema | BooleanSchema | NullableSchema<any> | ObjectSchema<any, any> | RecordSchema<any, any> | ArraySchema<any> | TupleSchema<any, any> | IntersectSchema<any> | UnionSchema<any> | VariantSchema<any, any> | PicklistSchema<any> | EnumSchema<any> | LazySchema<any> | DateSchema | NullishSchema<any> | OptionalSchema<any> | UndefinedSchema;

declare const DateStrategy: {
    readonly string: "string";
    readonly integer: "integer";
};
type DateStrategy = ValueOf<typeof DateStrategy>;
declare const UndefinedStrategy: {
    readonly any: "any";
    readonly null: "null";
};
type UndefinedStrategy = ValueOf<typeof UndefinedStrategy>;
declare const BigIntStrategy: {
    readonly string: "string";
    readonly integer: "integer";
};
type BigIntStrategy = ValueOf<typeof BigIntStrategy>;
interface ToJSONSchemaOptions {
    /**
     * Main schema (referenced at the root of the JSON schema).
     */
    schema?: BaseSchema | BaseSchemaAsync;
    /**
     * Additional schemas (referenced in the JSON schema `definitions`).
     */
    definitions?: Record<string, SupportedSchemas>;
    /**
     * Make all object type strict (`additionalProperties: false`).
     */
    strictObjectTypes?: boolean;
    /**
     * Date output:
     * - 'integer' sets the type to 'integer' and format to 'unix-time'.
     * - 'string' sets the type to 'string' and format to 'date-time'.
     */
    dateStrategy?: DateStrategy;
    /**
     * Undefined output:
     * - 'any' output an empty schema (the "any" schema)
     * - 'null' sets the type to 'null'
     */
    undefinedStrategy?: UndefinedStrategy;
    /**
     * How bigint schema should be converted:
     * - 'integer': uses integer type with format 'int64' (see https://ajv.js.org/packages/ajv-formats.html#formats)
     * - 'string': uses string type
     */
    bigintStrategy?: BigIntStrategy;
    /**
     * If true, do not throw an error on validations that cannot be
     * converted to JSON schema, like `custom`.
     */
    ignoreUnknownValidation?: boolean;
    /**
     * Customize how valibot schemas of the given type are converted to JSON schema.
     *
     * @example
     *   // Make valibot `instance()` schema convert to the "any" JSON schema (no validation)
     *   { customSchemaConversion: { instance: (schema) => ({}) }  }
     */
    customSchemaConversion?: Record<string, SchemaConverter<BaseSchema>>;
}
interface Context extends Omit<ToJSONSchemaOptions, 'schema' | 'definitions'> {
    /**
     * Mapping from schema to name
     */
    defNameMap: DefinitionNameMap;
}
type DefinitionNameMap = Map<SupportedSchemas, string>;
type BaseConverter = (schema: SupportedSchemas) => JSONSchema7;
type SchemaConverter<S extends BaseSchema> = (schema: S, convert: BaseConverter, context: Context) => JSONSchema7;

/**
 * Convert Valibot schemas to JSON schema.
 */
declare function toJSONSchema(options: ToJSONSchemaOptions): JSONSchema7;

declare const JSON_SCHEMA_FEATURES_KEY = "__json_schema_features";
type JSONSchemaFeatures = Partial<JSONSchema7>;
interface WithJSONSchemaFeatures {
    [JSON_SCHEMA_FEATURES_KEY]: JSONSchemaFeatures;
}
declare function withJSONSchemaFeatures<S extends BaseSchema>(schema: S, features: JSONSchemaFeatures): S & WithJSONSchemaFeatures;

export { ToJSONSchemaOptions, toJSONSchema, withJSONSchemaFeatures };
