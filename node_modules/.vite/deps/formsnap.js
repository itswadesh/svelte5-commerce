import "./chunk-MTEOPVPH.js";
import {
  writable
} from "./chunk-ICWSEBJ7.js";
import {
  add_locations,
  append,
  bind_this,
  comment,
  each,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  legacy_rest_props,
  prop,
  set_attributes,
  store_get,
  store_unsub,
  template,
  unsubscribe_on_destroy,
  wrap_snippet
} from "./chunk-X32BZYXW.js";
import "./chunk-UGQLD3FY.js";
import "./chunk-PMCBTWW3.js";
import "./chunk-5OAVULKH.js";
import {
  child,
  deep_read_state,
  derived_safe_equal,
  first_child,
  get,
  getContext,
  hasContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_source,
  pop,
  push,
  set,
  setContext,
  set_text,
  slot,
  source,
  template_effect,
  unwrap
} from "./chunk-Q25YKQMG.js";
import {
  validate_component,
  validate_store
} from "./chunk-WHOONRM5.js";
import "./chunk-IP2U24VQ.js";
import "./chunk-YWUGNIHA.js";
import "./chunk-AXYXVOZD.js";

// node_modules/formsnap/dist/context.js
var FORM_FIELD = Symbol("FORM_FIELD_CTX");
function setFormField(props) {
  setContext(FORM_FIELD, props);
  return props;
}
function getFormField() {
  if (!hasContext(FORM_FIELD)) {
    ctxError("Form.Field");
  }
  return getContext(FORM_FIELD);
}
var FORM_CONTROL = Symbol("FORM_CONTROL_CTX");
function setFormControl(props) {
  setContext(FORM_CONTROL, props);
  return props;
}
function getFormControl() {
  if (!hasContext(FORM_CONTROL)) {
    ctxError("<Control />");
  }
  return getContext(FORM_CONTROL);
}
function ctxError(ctx) {
  throw new Error(`Unable to find \`${ctx}\` context. Did you forget to wrap the component in a \`${ctx}\`?`);
}

// node_modules/formsnap/dist/internal/utils/attributes.js
function getAriaDescribedBy({ fieldErrorsId = void 0, descriptionId = void 0, errors }) {
  let describedBy = "";
  if (descriptionId) {
    describedBy += descriptionId + " ";
  }
  if (errors.length && fieldErrorsId) {
    describedBy += fieldErrorsId;
  }
  return describedBy ? describedBy.trim() : void 0;
}
function getAriaRequired(constraints) {
  if (!("required" in constraints))
    return void 0;
  return constraints.required ? "true" : void 0;
}
function getAriaInvalid(errors) {
  return errors && errors.length ? "true" : void 0;
}
function getDataFsError(errors) {
  return errors && errors.length ? "" : void 0;
}

// node_modules/formsnap/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// node_modules/formsnap/dist/internal/utils/id.js
function generateId() {
  return nanoid(5);
}

// node_modules/formsnap/dist/internal/utils/errors.js
function extractErrorArray(errors) {
  if (Array.isArray(errors))
    return errors;
  if (typeof errors === "object" && "_errors" in errors) {
    if (errors._errors !== void 0)
      return errors._errors;
  }
  return [];
}

// node_modules/formsnap/dist/components/description.svelte
mark_module_start();
Description.filename = ".../dist/components/description.svelte";
var root_2 = add_locations(template(`<div><!></div>`), Description.filename, [[36, 1]]);
function Description($$anchor, $$props) {
  if (new.target === Description)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["id", "asChild", "el"]);
  push($$props, false, Description);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $descriptionId = () => (validate_store(descriptionId, "descriptionId"), store_get(descriptionId, "$descriptionId", $$subscriptions));
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$subscriptions));
  const descriptionAttrs = mutable_source();
  const { descriptionId, errors } = getFormField();
  let id = prop($$props, "id", 8, generateId);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  legacy_pre_effect(() => deep_read_state(id()), () => {
    descriptionId.set(id());
  });
  legacy_pre_effect(
    () => ($descriptionId(), $errors(), deep_read_state($$restProps)),
    () => {
      set(descriptionAttrs, {
        id: $descriptionId(),
        "data-fs-error": getDataFsError($errors()),
        "data-fs-description": "",
        ...$$restProps
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props.children,
        {
          get descriptionAttrs() {
            return get(descriptionAttrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        $$props.children,
        {
          get descriptionAttrs() {
            return get(descriptionAttrs);
          }
        },
        null
      );
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(descriptionAttrs) }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Description);
  const filename = Description.filename;
  Description = hmr(s);
  Description.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var description_default = Description;
mark_module_end(Description);

// node_modules/formsnap/dist/internal/utils/path.js
function getValueAtPath(path, obj) {
  const keys = path.split(/[[\].]/).filter(Boolean);
  let value = obj;
  for (const key of keys) {
    if (typeof value !== "object" || value === null) {
      return void 0;
    }
    value = value[key];
  }
  return value;
}

// node_modules/formsnap/dist/components/field.svelte
mark_module_start();
Field.filename = ".../dist/components/field.svelte";
function Field($$anchor, $$props) {
  if (new.target === Field)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  push($$props, false, Field);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $formErrors = () => (validate_store(get(formErrors), "formErrors"), store_get(get(formErrors), "$formErrors", $$subscriptions));
  const $formConstraints = () => (validate_store(get(formConstraints), "formConstraints"), store_get(get(formConstraints), "$formConstraints", $$subscriptions));
  const $formTainted = () => (validate_store(get(formTainted), "formTainted"), store_get(get(formTainted), "$formTainted", $$subscriptions));
  const $formData = () => (validate_store(get(formData), "formData"), store_get(get(formData), "$formData", $$subscriptions));
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$subscriptions));
  const $tainted = () => (validate_store(tainted, "tainted"), store_get(tainted, "$tainted", $$subscriptions));
  const formErrors = mutable_source();
  const formConstraints = mutable_source();
  const formTainted = mutable_source();
  const formData = mutable_source();
  const field = {
    name: writable($$props.name),
    errors: writable([]),
    constraints: writable({}),
    tainted: writable(false),
    fieldErrorsId: writable(),
    descriptionId: writable(),
    form: $$props.form
  };
  const { tainted, errors } = field;
  setFormField(field);
  legacy_pre_effect(
    () => (get(formErrors), get(formConstraints), get(formTainted), get(formData), deep_read_state($$props.form)),
    () => {
      (() => {
        const tmp = $$props.form;
        store_unsub(set(formErrors, tmp.errors), "$formErrors", $$subscriptions), store_unsub(set(formConstraints, tmp.constraints), "$formConstraints", $$subscriptions), store_unsub(set(formTainted, tmp.tainted), "$formTainted", $$subscriptions), store_unsub(set(formData, tmp.form), "$formData", $$subscriptions);
        return tmp;
      })();
    }
  );
  legacy_pre_effect(() => deep_read_state($$props.name), () => {
    field.name.set($$props.name);
  });
  legacy_pre_effect(
    () => (deep_read_state($$props.name), $formErrors()),
    () => {
      field.errors.set(extractErrorArray(getValueAtPath($$props.name, $formErrors())));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state($$props.name), $formConstraints()),
    () => {
      field.constraints.set(getValueAtPath($$props.name, $formConstraints()) ?? {});
    }
  );
  legacy_pre_effect(
    () => ($formTainted(), deep_read_state($$props.name)),
    () => {
      field.tainted.set($formTainted() ? getValueAtPath($$props.name, $formTainted()) === true : false);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props.children,
    {
      get value() {
        return $formData()[$$props.name];
      },
      get errors() {
        return $errors();
      },
      get tainted() {
        return $tainted();
      },
      get constraints() {
        return $formConstraints()[$$props.name];
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Field);
  const filename = Field.filename;
  Field = hmr(s);
  Field.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var field_default = Field;
mark_module_end(Field);

// node_modules/formsnap/dist/components/control.svelte
mark_module_start();
Control.filename = ".../dist/components/control.svelte";
function Control($$anchor, $$props) {
  if (new.target === Control)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  push($$props, false, Control);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$subscriptions));
  const $name = () => (validate_store(name, "name"), store_get(name, "$name", $$subscriptions));
  const $idStore = () => (validate_store(idStore, "idStore"), store_get(idStore, "$idStore", $$subscriptions));
  const $fieldErrorsId = () => (validate_store(fieldErrorsId, "fieldErrorsId"), store_get(fieldErrorsId, "$fieldErrorsId", $$subscriptions));
  const $descriptionId = () => (validate_store(descriptionId, "descriptionId"), store_get(descriptionId, "$descriptionId", $$subscriptions));
  const $constraints = () => (validate_store(constraints, "constraints"), store_get(constraints, "$constraints", $$subscriptions));
  const errorAttr = mutable_source();
  const attrs = mutable_source();
  const labelAttrs = mutable_source();
  let id = prop($$props, "id", 8, generateId);
  const {
    name,
    fieldErrorsId,
    descriptionId,
    errors,
    constraints
  } = getFormField();
  const controlContext = {
    id: writable(id()),
    attrs: writable(),
    labelAttrs: writable()
  };
  const { id: idStore } = controlContext;
  setFormControl(controlContext);
  legacy_pre_effect(() => deep_read_state(id()), () => {
    controlContext.id.set(id());
  });
  legacy_pre_effect(() => $errors(), () => {
    set(errorAttr, getDataFsError($errors()));
  });
  legacy_pre_effect(
    () => ($name(), $idStore(), get(errorAttr), $fieldErrorsId(), $descriptionId(), $errors(), $constraints()),
    () => {
      set(attrs, {
        name: $name(),
        id: $idStore(),
        "data-fs-error": get(errorAttr),
        "aria-describedby": getAriaDescribedBy({
          fieldErrorsId: $fieldErrorsId(),
          descriptionId: $descriptionId(),
          errors: $errors()
        }),
        "aria-invalid": getAriaInvalid($errors()),
        "aria-required": getAriaRequired($constraints()),
        "data-fs-control": ""
      });
    }
  );
  legacy_pre_effect(() => ($idStore(), get(errorAttr)), () => {
    set(labelAttrs, {
      for: $idStore(),
      "data-fs-label": "",
      "data-fs-error": get(errorAttr)
    });
  });
  legacy_pre_effect(() => get(attrs), () => {
    controlContext.attrs.set(get(attrs));
  });
  legacy_pre_effect(() => get(labelAttrs), () => {
    controlContext.labelAttrs.set(get(labelAttrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props.children,
    {
      get attrs() {
        return get(attrs);
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Control);
  const filename = Control.filename;
  Control = hmr(s);
  Control.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var control_default = Control;
mark_module_end(Control);

// node_modules/formsnap/dist/components/label.svelte
mark_module_start();
Label.filename = ".../dist/components/label.svelte";
var root_22 = add_locations(template(`<label><!></label>`), Label.filename, [[36, 1]]);
function Label($$anchor, $$props) {
  if (new.target === Label)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Label);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $labelAttrsStore = () => (validate_store(labelAttrsStore, "labelAttrsStore"), store_get(labelAttrsStore, "$labelAttrsStore", $$subscriptions));
  const localLabelAttrs = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { labelAttrs: labelAttrsStore } = getFormControl();
  legacy_pre_effect(
    () => ($labelAttrsStore(), deep_read_state($$restProps)),
    () => {
      set(localLabelAttrs, { ...$labelAttrsStore(), ...$$restProps });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props.children,
        {
          get labelAttrs() {
            return get(localLabelAttrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var label = root_22();
      bind_this(label, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(label);
      slot(
        node_2,
        $$props.children,
        {
          get labelAttrs() {
            return get(localLabelAttrs);
          }
        },
        null
      );
      template_effect(() => attributes = set_attributes(label, attributes, { ...get(localLabelAttrs) }, true, ""));
      append($$anchor2, label);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Label);
  const filename = Label.filename;
  Label = hmr(s);
  Label.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var label_default = Label;
mark_module_end(Label);

// node_modules/formsnap/dist/components/field-errors.svelte
mark_module_start();
Field_errors.filename = ".../dist/components/field-errors.svelte";
var each_block = add_locations(template(`<div> </div>`), Field_errors.filename, [[49, 4]]);
var root_23 = add_locations(template(`<div><!></div>`), Field_errors.filename, [[46, 1]]);
function Field_errors($$anchor, $$props) {
  if (new.target === Field_errors)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["id", "asChild", "el"]);
  push($$props, false, Field_errors);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $errors = () => (validate_store(get(errors), "errors"), store_get(get(errors), "$errors", $$subscriptions));
  const $fieldErrorsId = () => (validate_store(fieldErrorsId, "fieldErrorsId"), store_get(fieldErrorsId, "$fieldErrorsId", $$subscriptions));
  const errorAttr = mutable_source();
  const fieldErrorsAttrs = mutable_source();
  const errorAttrs = mutable_source();
  const tmp = getFormField(), fieldErrorsId = tmp.fieldErrorsId, errors = mutable_source(tmp.errors);
  let id = prop($$props, "id", 8, generateId);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  legacy_pre_effect(() => $errors(), () => {
    set(errorAttr, getDataFsError($errors()));
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    fieldErrorsId.set(id());
  });
  legacy_pre_effect(
    () => ($fieldErrorsId(), get(errorAttr), deep_read_state($$restProps)),
    () => {
      set(fieldErrorsAttrs, {
        id: $fieldErrorsId(),
        "data-fs-error": get(errorAttr),
        "data-fs-field-errors": "",
        "aria-live": "assertive",
        ...$$restProps
      });
    }
  );
  legacy_pre_effect(() => get(errorAttr), () => {
    set(errorAttrs, {
      "data-fs-field-error": "",
      "data-fs-error": get(errorAttr)
    });
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props.children,
        {
          get errors() {
            return $errors();
          },
          get fieldErrorsAttrs() {
            return get(fieldErrorsAttrs);
          },
          get errorAttrs() {
            return get(errorAttrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_23();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        $$props.children,
        {
          get errors() {
            return $errors();
          },
          get fieldErrorsAttrs() {
            return get(fieldErrorsAttrs);
          },
          get errorAttrs() {
            return get(errorAttrs);
          }
        },
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          each(node_3, 1, $errors, index, ($$anchor4, error, $$index) => {
            var div_1 = each_block();
            let attributes_1;
            var text = child(div_1);
            template_effect(() => {
              attributes_1 = set_attributes(div_1, attributes_1, { ...get(errorAttrs) }, true, "");
              set_text(text, unwrap(error));
            });
            append($$anchor4, div_1);
          });
          append($$anchor3, fragment_2);
        }
      );
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(fieldErrorsAttrs) }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Field_errors);
  const filename = Field_errors.filename;
  Field_errors = hmr(s);
  Field_errors.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var field_errors_default = Field_errors;
mark_module_end(Field_errors);

// node_modules/formsnap/dist/components/fieldset.svelte
mark_module_start();
Fieldset.filename = ".../dist/components/fieldset.svelte";
var root_24 = add_locations(template(`<fieldset><!></fieldset>`), Fieldset.filename, [[40, 2]]);
function Fieldset($$anchor, $$props) {
  if (new.target === Fieldset)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["form", "name", "asChild", "el"]);
  push($$props, false, Fieldset);
  const fieldsetAttrs = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(fieldsetAttrs, { "data-fs-fieldset": "", ...$$restProps });
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  validate_component(field_default)(node, {
    get form() {
      return $$props.form;
    },
    get name() {
      return $$props.name;
    },
    children: wrap_snippet(($$anchor2, $$slotProps) => {
      const value = derived_safe_equal(() => $$slotProps.value);
      const errors = derived_safe_equal(() => $$slotProps.errors);
      const tainted = derived_safe_equal(() => $$slotProps.tainted);
      const constraints = derived_safe_equal(() => $$slotProps.constraints);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        asChild,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(
            node_2,
            $$props.children,
            {
              get fieldsetAttrs() {
                return get(fieldsetAttrs);
              },
              get value() {
                return get(value);
              },
              get errors() {
                return get(errors);
              },
              get tainted() {
                return get(tainted);
              },
              get constraints() {
                return get(constraints);
              }
            },
            null
          );
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var fieldset = root_24();
          bind_this(fieldset, ($$value) => el($$value), () => el());
          let attributes;
          var node_3 = child(fieldset);
          slot(
            node_3,
            $$props.children,
            {
              get fieldsetAttrs() {
                return get(fieldsetAttrs);
              },
              get value() {
                return get(value);
              },
              get errors() {
                return get(errors);
              },
              get tainted() {
                return get(tainted);
              },
              get constraints() {
                return get(constraints);
              }
            },
            null
          );
          template_effect(() => attributes = set_attributes(
            fieldset,
            attributes,
            {
              ...get(fieldsetAttrs),
              "data-fs-error": getDataFsError(get(errors))
            },
            true,
            ""
          ));
          append($$anchor3, fieldset);
        }
      );
      append($$anchor2, fragment_1);
    })
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Fieldset);
  const filename = Fieldset.filename;
  Fieldset = hmr(s);
  Fieldset.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var fieldset_default = Fieldset;
mark_module_end(Fieldset);

// node_modules/formsnap/dist/components/legend.svelte
mark_module_start();
Legend.filename = ".../dist/components/legend.svelte";
var root_25 = add_locations(template(`<legend><!></legend>`), Legend.filename, [[30, 1]]);
function Legend($$anchor, $$props) {
  if (new.target === Legend)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Legend);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$subscriptions));
  const legendAttrs = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { errors } = getFormField();
  legacy_pre_effect(
    () => ($errors(), deep_read_state($$restProps)),
    () => {
      set(legendAttrs, {
        "data-fs-legend": "",
        "data-fs-error": getDataFsError($errors()),
        ...$$restProps
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props.children,
        {
          get legendAttrs() {
            return get(legendAttrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var legend = root_25();
      bind_this(legend, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(legend);
      slot(
        node_2,
        $$props.children,
        {
          get legendAttrs() {
            return get(legendAttrs);
          }
        },
        null
      );
      template_effect(() => attributes = set_attributes(legend, attributes, { ...get(legendAttrs) }, true, ""));
      append($$anchor2, legend);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Legend);
  const filename = Legend.filename;
  Legend = hmr(s);
  Legend.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var legend_default = Legend;
mark_module_end(Legend);

// node_modules/formsnap/dist/components/element-field.svelte
mark_module_start();
Element_field.filename = ".../dist/components/element-field.svelte";
function Element_field($$anchor, $$props) {
  if (new.target === Element_field)
    throw new Error("Instantiating a component with `new` is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information");
  push($$props, false, Element_field);
  const $$subscriptions = {};
  unsubscribe_on_destroy($$subscriptions);
  const $parentDescriptionId = () => (validate_store(parentDescriptionId, "parentDescriptionId"), store_get(parentDescriptionId, "$parentDescriptionId", $$subscriptions));
  const $formErrors = () => (validate_store(get(formErrors), "formErrors"), store_get(get(formErrors), "$formErrors", $$subscriptions));
  const $formConstraints = () => (validate_store(get(formConstraints), "formConstraints"), store_get(get(formConstraints), "$formConstraints", $$subscriptions));
  const $formTainted = () => (validate_store(get(formTainted), "formTainted"), store_get(get(formTainted), "$formTainted", $$subscriptions));
  const $descriptionId = () => (validate_store(descriptionId, "descriptionId"), store_get(descriptionId, "$descriptionId", $$subscriptions));
  const $formData = () => (validate_store(get(formData), "formData"), store_get(get(formData), "$formData", $$subscriptions));
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$subscriptions));
  const $tainted = () => (validate_store(tainted, "tainted"), store_get(tainted, "$tainted", $$subscriptions));
  const formErrors = mutable_source();
  const formConstraints = mutable_source();
  const formTainted = mutable_source();
  const formData = mutable_source();
  const path = mutable_source();
  const value = mutable_source();
  const { descriptionId: parentDescriptionId } = getFormField();
  const elementField = {
    name: writable(get(path)),
    errors: writable([]),
    constraints: writable({}),
    tainted: writable(false),
    fieldErrorsId: writable(),
    descriptionId: writable($parentDescriptionId()),
    form: $$props.form
  };
  const { tainted, errors, descriptionId } = elementField;
  function splitArrayPath(name2) {
    const [path2, index2] = name2.split(/[[\]]/);
    return [path2, index2];
  }
  setFormField(elementField);
  legacy_pre_effect(
    () => (get(formErrors), get(formConstraints), get(formTainted), get(formData), deep_read_state($$props.form)),
    () => {
      (() => {
        const tmp = $$props.form;
        store_unsub(set(formErrors, tmp.errors), "$formErrors", $$subscriptions), store_unsub(set(formConstraints, tmp.constraints), "$formConstraints", $$subscriptions), store_unsub(set(formTainted, tmp.tainted), "$formTainted", $$subscriptions), store_unsub(set(formData, tmp.form), "$formData", $$subscriptions);
        return tmp;
      })();
    }
  );
  legacy_pre_effect(
    () => (get(path), deep_read_state($$props.name)),
    () => {
      (() => {
        const tmp_1 = splitArrayPath($$props.name);
        set(path, tmp_1[0]);
        return tmp_1;
      })();
    }
  );
  legacy_pre_effect(() => get(path), () => {
    elementField.name.set(get(path));
  });
  legacy_pre_effect(
    () => (deep_read_state($$props.name), $formErrors()),
    () => {
      errors.set(extractErrorArray(getValueAtPath($$props.name, $formErrors())));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state($$props.name), $formConstraints()),
    () => {
      elementField.constraints.set(getValueAtPath($$props.name, $formConstraints()) ?? {});
    }
  );
  legacy_pre_effect(
    () => ($formTainted(), deep_read_state($$props.name)),
    () => {
      tainted.set($formTainted() ? getValueAtPath($$props.name, $formTainted()) === true ? true : false : false);
    }
  );
  legacy_pre_effect(
    () => ($descriptionId(), $parentDescriptionId()),
    () => {
      if (!$descriptionId() && $parentDescriptionId()) {
        elementField.descriptionId.set($parentDescriptionId());
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state($$props.name), $formData()),
    () => {
      set(value, getValueAtPath($$props.name, $formData()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props.children,
    {
      get value() {
        return get(value);
      },
      get errors() {
        return $errors();
      },
      get tainted() {
        return $tainted();
      },
      get constraints() {
        return $formConstraints()[$$props.name];
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Element_field);
  const filename = Element_field.filename;
  Element_field = hmr(s);
  Element_field.filename = filename;
  if (import.meta.hot.acceptExports) {
    import.meta.hot.acceptExports(["default"], (module) => {
      set(s, module.default);
    });
  } else {
    import.meta.hot.accept((module) => {
      set(s, module.default);
    });
  }
}
var element_field_default = Element_field;
mark_module_end(Element_field);
export {
  control_default as Control,
  description_default as Description,
  element_field_default as ElementField,
  field_default as Field,
  field_errors_default as FieldErrors,
  fieldset_default as Fieldset,
  label_default as Label,
  legend_default as Legend,
  getFormControl,
  getFormField,
  setFormControl,
  setFormField
};
//# sourceMappingURL=formsnap.js.map
